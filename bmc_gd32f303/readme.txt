
***********************************************************************************************








***********************************************************************************************








***********************************************************************************************


ADC转换步骤：
1、各模块 自己采集的时候 ，就对值进行标准化输出，byte格式 raw
	api_sensorConvertIPMBValBySensorNum
	api_sensorSetValRaw
	api_sensorConvert2HumanVal
	api_sensorSetValHuman
2、timer，进行转换化human值
	dev main:api_sensorConvert2HumanVal
3、adc_test()或devTask
	api_sensorGetValIPMB，直接获取
	api_sensorGetValHuman，直接获取




***********************************************************************************************

主机获取所有从机的采集值方案：
1、主机定时，主动循环读取各从机的adc原始值
2、主从，采用同一份sensor配置总表
	--表中带ADC采集通道和slave address
	--ADC通道和自身的ADC采集相关联
	--slave address，是为了在总表当中，因为存在多个相同ADC通道的sensor表，即每个slave对应一组表。
3、从机根据 自己的配置表，装载数据，并返回检测数据包
4、不同的从机，采用相同的ADC通道，但是配置表又不一样。
	所以配置表中的sensorOEM = Addr
5、真实值的转换关系
但不同的ADC raw，需要用不同的sensor配置表，即MR，进行转换
convert(slave address, ADC channle, adc raw)
6、可以利用本地的配置表，利用 ipmi_convert_reading，获取6个阈值 
	--后期再添加
	利用ipmi_convert_reading 计算真实值
	--只计算，获取最重要的 真实值

***********************************************************************************************

捕获原理
1、计算出两次上升沿之间所花费的时间T
2、T的导数，就是待求的频率f。
3、转速 n = f*60/p 

4、连续两次上升沿中断时，分别保存cap_value_first、cap_value_second，
	可计算出单位时间T内，计数总数为(total_value)，而每次计数时的工作频率是prescaler，(1M)，即St=1us
5、T=total_value * St
6、f = 1/(T) = 1/(total_value * St)=1M/total_value

***********************************************************************************************

适配了bmc_gd32f303，编译成功



***********************************************************************************************

参考代码用的是bmc_gd32f207 M3
调试板是bmc_gd32f107   M3    GD32F103VBT6

最终目标板是bmc_gd32f303 M4



***********************************************************************************************
